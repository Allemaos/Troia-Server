@startuml


title Troia architecture proposal

note "We should try to avoid passing objects like Map/Set.\nInstead we should try to make corresponding classes that would have some semantic information about such mapping" as OveralNote


package "core.elements" {
    abstract class Label {
        boolean equals(Label other)
        int hash()
        double difference(Label other)
    }
    Label <|-- NominalLabel
    Label <|-- ContinousLabel

    class Worker {
        id/name
    }
    class Item {
        id/name
    }
    Vote "1" o-- Label
    Vote "1" o-- Worker
    Vote "1" o-- Item

    Item <|-- ItemWithKnownLabel
    ItemWithKnownLabel <|-- GoldItem
    ItemWithKnownLabel <|-- ValidationItem
}

note "I'm not sure whether we should use State Pattern to make it possible to change suddenly to GoldObject" as NoteTroiaObject
Item .. NoteTroiaObject


package "core.algorithms" {
    interface LabelCostCalculator {
        calculateLabelCost(Label, ProbabilityDistribution<Label>, CostMatrix<Label>)
    }

    interface LabelChoosingAlgorithm {
        chooseLabel(ProbabilityDistribution<Label>, CostMatrix<Label>)
    }

    MinCostLabelChoosingAlgorithm o-- LabelCostCalculator
    MinCostLabelChoosingAlgorithm --|> LabelChoosingAlgorithm
    MaxProbabilityLabel --|> LabelChoosingAlgorithm

}

package "math.utils" {
    class CostMatrix<T>
    class ProbabilityDistribution<T>
    class ProbabilityDistributionGenerators<T>{
        {static} ProbabilityDistribution<T> uniform(Collection<T>)
        {static} ProbabilityDistribution<T> constant(Collection<T>, Double)
    }
}

note "Implements Map like API that T -> Double\nalso makes iteration over pair <T, Double>\nFor elements not present it returns 0 probability" as NoteProbabilityDistribution
note "Clear names like <B>trueValue</B>, <B>predictedValue</B>" as NoteCostMatrix

ProbabilityDistribution .. NoteProbabilityDistribution
CostMatrix .. NoteCostMatrix


package "Crowdsourcing Quality Algorithm" {
    interface DataStorage {
        getObjects()
        addWorkerLabel()
        .. etc ..
    }

    class WorkerData {
        stores extra informations about Worker
    }
    WorkerData *-- Worker

    abstract Model {
        represents model created by
        algorithm to store its state
    }

    interface LabelProbabilityDistributionCalculator {
        calculateLabelProbabilityDistribution(model, storage, object)
    }
}


note "Implemented by DBDataStorage, FileDataStorage etc" as NoteDataStorage
DataStorage .. NoteDataStorage


package TestGenerator {
    class RandomWorker {
        and many subclasses corresponding
        to some distribution etc.
    }
    RandomWorker --|> Worker

}

package RESTService {
    abstract class Serializer
    Serializer <|-- JSONSerializer
    Serializer <|-- AvroSerializer
}

@enduml