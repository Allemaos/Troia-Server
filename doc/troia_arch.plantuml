@startuml


title Troia architecture proposal

package "core.elements" {
    abstract class Label {
        boolean equals(Label other)
        int hash()
        double difference(Label other)
    }
    Label <|-- NominalLabel
    Label <|-- ContinousLabel

    class Worker {
        id/name
    }
    class Item {
        id/name
    }
    Vote "1" o-- Label
    Vote "1" o-- Worker
    Vote "1" o-- Item

    Item <|-- ItemWithKnownLabel
    ItemWithKnownLabel <|-- GoldItem
    ItemWithKnownLabel <|-- ValidationItem
}

note "I'm not sure whether we should use State Pattern to make it possible to change suddenly to GoldObject" as NoteTroiaObject
Item .. NoteTroiaObject


package "core.algorithms" {
    interface LabelCostCalculator {
        calculateLabelCost(Label, ProbabilityDistribution<Label>, CostMatrix<Label>)
    }

    interface LabelChoosingAlgorithm {
        chooseLabel(ProbabilityDistribution<Label>, CostMatrix<Label>)
    }

    MinCostLabelChoosingAlgorithm o-- LabelCostCalculator
    MinCostLabelChoosingAlgorithm --|> LabelChoosingAlgorithm
    MaxProbabilityLabel --|> LabelChoosingAlgorithm

}

package "utils.math" {
    class CostMatrix<T>
    class ProbabilityDistribution<T>
    class ProbabilityDistributionGenerators<T>{
        {static} ProbabilityDistribution<T> uniform(Collection<T>)
        {static} ProbabilityDistribution<T> constant(Collection<T>, Double)
    }
}

note "Implements Map like API that T -> Double\nalso makes iteration over pair <T, Double>\nFor elements not present it returns 0 probability" as NoteProbabilityDistribution
note "Clear names like <B>trueValue</B>, <B>predictedValue</B>" as NoteCostMatrix

ProbabilityDistribution .. NoteProbabilityDistribution
CostMatrix .. NoteCostMatrix


package "crowdsourcingQuality.core" {

    abstract class CrowdsourcingQualityAlgorithm

    interface DataStorage {
        getObjects()
        addWorkerLabel()
        .. etc ..
    }

    class WorkerData {
        stores extra informations about Worker
    }
    WorkerData *-- Worker

    abstract CrowdsourcingQualityAlogirhtmModel {
        represents model created by
        algorithm to store its state
    }

    interface LabelProbabilityDistributionCalculator {
        calculateLabelProbabilityDistribution(model, storage, object)
    }

    CrowdsourcingQualityAlgorithm o-- DataStorage
    CrowdsourcingQualityAlgorithm o-- LabelProbabilityDistributionCalculator
    CrowdsourcingQualityAlgorithm o-- LabelChoosingAlgorithm
    CrowdsourcingQualityAlgorithm o-- CrowdsourcingQualityAlogirhtmModel
    CrowdsourcingQualityAlogirhtmModel "*" o-- WorkerData
}

abstract class DawidSkene

MajorityVote --|> CrowdsourcingQualityAlgorithm

DawidSkene --|> CrowdsourcingQualityAlgorithm
DawidSkene <|-- IncrementalDawidSkene


note "Implemented by DBDataStorage, FileDataStorage etc" as NoteDataStorage
DataStorage .. NoteDataStorage


package TestGenerator {
    class RandomWorker {
        and many subclasses corresponding
        to some distribution etc.
    }
    RandomWorker --|> Worker

}

package RESTService {
    interface Serializer
    Serializer <|-- JSONSerializer
    Serializer <|-- AvroSerializer
}

@enduml